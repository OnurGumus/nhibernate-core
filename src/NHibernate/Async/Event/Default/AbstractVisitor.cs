//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using NHibernate.Persister.Entity;
using NHibernate.Type;

namespace NHibernate.Event.Default
{
	using System.Threading.Tasks;
	using System;
	/// <summary> 
	/// Abstract superclass of algorithms that walk a tree of property values of an entity, and
	/// perform specific functionality for collections, components and associated entities. 
	/// </summary>
	public abstract partial class AbstractVisitor
	{

		/// <summary> Dispatch each property value to ProcessValue(). </summary>
		/// <param name="values"> </param>
		/// <param name="types"> </param>
		internal async Task ProcessValuesAsync(object[] values, IType[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				if (IncludeProperty(values, i))
					await (ProcessValueAsync(i, values, types)).ConfigureAwait(false);
			}
		}

		internal virtual Task ProcessValueAsync(int i, object[] values, IType[] types)
		{
			return ProcessValueAsync(values[i], types[i]);
		}

		/// <summary> 
		/// Visit a property value. Dispatch to the correct handler for the property type.
		/// </summary>
		/// <param name="value"> </param>
		/// <param name="type"> </param>
		internal Task<object> ProcessValueAsync(object value, IType type)
		{
			try
			{
				if (type.IsCollectionType)
				{
					//even process null collections
					return ProcessCollectionAsync(value, (CollectionType)type);
				}
				else if (type.IsEntityType)
				{
					return Task.FromResult<object>(ProcessEntity(value, (EntityType)type));
				}
				else if (type.IsComponentType)
				{
					return ProcessComponentAsync(value, (IAbstractComponentType)type);
				}
				else
				{
					return Task.FromResult<object>(null);
				}
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		/// <summary>
		/// Visit a component. Dispatch each property to <see cref="ProcessValuesAsync(object[],NHibernate.Type.IType[])"/>
		/// </summary>
		/// <param name="component"></param>
		/// <param name="componentType"></param>
		/// <returns></returns>
		internal virtual async Task<object> ProcessComponentAsync(object component, IAbstractComponentType componentType)
		{
			if (component != null)
			{
				await (ProcessValuesAsync(componentType.GetPropertyValues(component, session), componentType.Subtypes)).ConfigureAwait(false);
			}
			return null;
		}

		/// <summary>
		/// Visit a collection. Default superclass implementation is a no-op.
		/// </summary>
		/// <param name="value"></param>
		/// <param name="collectionType"></param>
		/// <returns></returns>
		internal virtual Task<object> ProcessCollectionAsync(object value, CollectionType collectionType)
		{
			try
			{
				return Task.FromResult<object>(null);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		/// <summary>
		/// Walk the tree starting from the given entity.
		/// </summary>
		/// <param name="obj"></param>
		/// <param name="persister"></param>
		internal virtual Task ProcessAsync(object obj, IEntityPersister persister)
		{
			try
			{
				return ProcessEntityPropertyValuesAsync(persister.GetPropertyValues(obj), persister.PropertyTypes);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public async Task ProcessEntityPropertyValuesAsync(object[] values, IType[] types)
		{
			for (int i = 0; i < types.Length; i++)
			{
				if (IncludeEntityProperty(values, i))
				{
					await (ProcessValueAsync(i, values, types)).ConfigureAwait(false);
				}
			}
		}
	}
}
