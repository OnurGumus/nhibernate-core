//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Data.Common;
using System.Reflection;
using NHibernate.Engine;
using NHibernate.Persister.Entity;
using NHibernate.Proxy;
using NHibernate.SqlTypes;
using NHibernate.Util;
using System.Collections.Generic;

namespace NHibernate.Type
{
	using System.Threading.Tasks;
	public partial class AnyType : AbstractType, IAbstractComponentType, IAssociationType
	{

		public override Task<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner)
		{
			try
			{
				return Task.FromException<object>(new NotSupportedException("object is a multicolumn type"));
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public override async Task<object> NullSafeGetAsync(DbDataReader rs, string[] names, ISessionImplementor session, object owner)
		{
			return await (ResolveAnyAsync((string)await (metaType.NullSafeGetAsync(rs, names[0], session, owner)).ConfigureAwait(false), 
				await (identifierType.NullSafeGetAsync(rs, names[1], session, owner)).ConfigureAwait(false), session)).ConfigureAwait(false);
		}

		public override async Task<object> HydrateAsync(DbDataReader rs, string[] names, ISessionImplementor session, object owner)
		{
			string entityName = (string)await (metaType.NullSafeGetAsync(rs, names[0], session, owner)).ConfigureAwait(false);
			object id = await (identifierType.NullSafeGetAsync(rs, names[1], session, owner)).ConfigureAwait(false);
			return new ObjectTypeCacheEntry(entityName, id);
		}

		public override Task<object> ResolveIdentifierAsync(object value, ISessionImplementor session, object owner)
		{
			try
			{
				ObjectTypeCacheEntry holder = (ObjectTypeCacheEntry)value;
				return ResolveAnyAsync(holder.entityName, holder.id, session);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public override Task<object> SemiResolveAsync(object value, ISessionImplementor session, object owner)
		{
			try
			{
				return Task.FromException<object>(new NotSupportedException("any mappings may not form part of a property-ref"));
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		public override async Task<object> AssembleAsync(object cached, ISessionImplementor session, object owner)
		{
			ObjectTypeCacheEntry e = cached as ObjectTypeCacheEntry;
			return (e == null) ? null : await (session.InternalLoadAsync(e.entityName, e.id, false, false)).ConfigureAwait(false);
		}

		public override Task<object> ReplaceAsync(object original, object current, ISessionImplementor session, object owner,
									   IDictionary copiedAlready)
		{
			try
			{
				if (original == null)
				{
					return Task.FromResult<object>(null);
				}
				else
				{
					string entityName = session.BestGuessEntityName(original);
					object id = ForeignKeys.GetEntityIdentifierIfNotUnsaved(entityName, original, session);
					return session.InternalLoadAsync(entityName, id, false, false);
				}
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		private async Task<object> ResolveAnyAsync(string entityName, object id, ISessionImplementor session)
		{
			return entityName == null || id == null ? null : await (session.InternalLoadAsync(entityName, id, false, false)).ConfigureAwait(false);
		}

	}
}
