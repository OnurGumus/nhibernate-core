//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System.Collections;
using NHibernate.AdoNet;
using NHibernate.Cfg;
using NUnit.Framework;

namespace NHibernate.Test.Ado
{
	using System.Threading.Tasks;
	using System.Threading;
	[TestFixture]
	public class BatcherFixtureAsync: TestCase
	{
		protected override string MappingsAssembly
		{
			get { return "NHibernate.Test"; }
		}

		protected override IList Mappings
		{
			get { return new[] { "Ado.VerySimple.hbm.xml", "Ado.AlmostSimple.hbm.xml" }; }
		}

		protected override void Configure(Configuration configuration)
		{
			configuration.SetProperty(Environment.FormatSql, "true");
			configuration.SetProperty(Environment.GenerateStatistics, "true");
			configuration.SetProperty(Environment.BatchSize, "10");
		}

		protected override bool AppliesTo(Engine.ISessionFactoryImplementor factory)
		{
			return !(factory.Settings.BatcherFactory is NonBatchingBatcherFactory);
		}

		[Test]
		[Description("The batcher should run all INSERT queries in only one roundtrip.")]
		public async Task OneRoundTripInsertsAsync()
		{
			sessions.Statistics.Clear();
			await (FillDbAsync(CancellationToken.None));

			Assert.That(sessions.Statistics.PrepareStatementCount, Is.EqualTo(1));
			await (CleanupAsync(CancellationToken.None));
		}

		private async Task CleanupAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			using (ISession s = sessions.OpenSession())
			using (s.BeginTransaction())
			{
				await (s.CreateQuery("delete from VerySimple").ExecuteUpdateAsync(cancellationToken));
				await (s.CreateQuery("delete from AlmostSimple").ExecuteUpdateAsync(cancellationToken));
				await (s.Transaction.CommitAsync(cancellationToken));
			}
		}

		private async Task FillDbAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			using (ISession s = sessions.OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				await (s.SaveAsync(new VerySimple {Id = 1, Name = "Fabio", Weight = 119.5}, cancellationToken));
				await (s.SaveAsync(new VerySimple {Id = 2, Name = "Fiamma", Weight = 9.8}, cancellationToken));
				await (tx.CommitAsync(cancellationToken));
			}
		}

		[Test]
		[Description("The batcher should run all UPDATE queries in only one roundtrip.")]
		public async Task OneRoundTripUpdateAsync()
		{
			await (FillDbAsync(CancellationToken.None));

			using (ISession s = sessions.OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				var vs1 = await (s.GetAsync<VerySimple>(1, CancellationToken.None));
				var vs2 = await (s.GetAsync<VerySimple>(2, CancellationToken.None));
				vs1.Weight -= 10;
				vs2.Weight -= 1;
				sessions.Statistics.Clear();
				await (s.UpdateAsync(vs1, CancellationToken.None));
				await (s.UpdateAsync(vs2, CancellationToken.None));
				await (tx.CommitAsync(CancellationToken.None));
			}

			Assert.That(sessions.Statistics.PrepareStatementCount, Is.EqualTo(1));
			await (CleanupAsync(CancellationToken.None));
		}

		[Test, Ignore("Not fixed yet.")]
		[Description("SqlClient: The batcher should run all different INSERT queries in only one roundtrip.")]
		public async Task SqlClientOneRoundTripForUpdateAndInsertAsync()
		{
			if (sessions.Settings.BatcherFactory is SqlClientBatchingBatcherFactory == false)
				Assert.Ignore("This test is for SqlClientBatchingBatcher only");

			await (FillDbAsync(CancellationToken.None));

			using(var sqlLog = new SqlLogSpy())
			using (ISession s = sessions.OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				await (s.SaveAsync(new VerySimple
				{
					Name = "test441",
					Weight = 894
				}, CancellationToken.None));

				await (s.SaveAsync(new AlmostSimple
				{
					Name = "test441",
					Weight = 894
				}, CancellationToken.None));

				await (tx.CommitAsync(CancellationToken.None));

				var log = sqlLog.GetWholeLog();
				//log should only contain NHibernate.SQL once, because that means 
				//that we ony generated a single batch (NHibernate.SQL log will output
				//once per batch)
				Assert.AreEqual(0, log.IndexOf("NHibernate.SQL"), "log should start with NHibernate.SQL");
				Assert.AreEqual(-1, log.IndexOf("NHibernate.SQL", "NHibernate.SQL".Length), "NHibernate.SQL should only appear once in the log");
			}

			await (CleanupAsync(CancellationToken.None));
		}

		[Test]
		[Description("SqlClient: The batcher log output should be formatted")]
		public async Task BatchedoutputShouldBeFormattedAsync()
		{
			if (sessions.Settings.BatcherFactory is SqlClientBatchingBatcherFactory == false)
				Assert.Ignore("This test is for SqlClientBatchingBatcher only");

			using (var sqlLog = new SqlLogSpy())
			{
				await (FillDbAsync(CancellationToken.None));
				var log = sqlLog.GetWholeLog();
				Assert.IsTrue(log.Contains("INSERT \n    INTO"));
			}

			await (CleanupAsync(CancellationToken.None));
		}


		[Test]
		[Description("The batcher should run all DELETE queries in only one roundtrip.")]
		public async Task OneRoundTripDeleteAsync()
		{
			await (FillDbAsync(CancellationToken.None));

			using (ISession s = sessions.OpenSession())
			using (ITransaction tx = s.BeginTransaction())
			{
				var vs1 = await (s.GetAsync<VerySimple>(1, CancellationToken.None));
				var vs2 = await (s.GetAsync<VerySimple>(2, CancellationToken.None));
				sessions.Statistics.Clear();
				await (s.DeleteAsync(vs1, CancellationToken.None));
				await (s.DeleteAsync(vs2, CancellationToken.None));
				await (tx.CommitAsync(CancellationToken.None));
			}

			Assert.That(sessions.Statistics.PrepareStatementCount, Is.EqualTo(1));
			await (CleanupAsync(CancellationToken.None));
		}

		[Test]
		[Description(@"Activating the SQL and turning off the batcher's log the log stream:
-should not contains adding to batch
-should contain batch command
-the batcher should work.")]
		public async Task SqlLogAsync()
		{
			using (new LogSpy(typeof(AbstractBatcher), true))
			{
				using (var sl = new SqlLogSpy())
				{
					sessions.Statistics.Clear();
					await (FillDbAsync(CancellationToken.None));
					string logs = sl.GetWholeLog();
					Assert.That(logs, Does.Not.Contain("Adding to batch").IgnoreCase);
					Assert.That(logs, Does.Contain("Batch command").IgnoreCase);
					Assert.That(logs, Does.Contain("INSERT").IgnoreCase);
				}
			}

			Assert.That(sessions.Statistics.PrepareStatementCount, Is.EqualTo(1));
			await (CleanupAsync(CancellationToken.None));
		}

		[Test]
		[Description(@"Activating the AbstractBatcher's log the log stream:
-should not contains batch info 
-should contain SQL log info only regarding batcher (SQL log should not be duplicated)
-the batcher should work.")]
		public async Task AbstractBatcherLogAsync()
		{
			using (new LogSpy(typeof(AbstractBatcher)))
			{
				using (var sl = new SqlLogSpy())
				{
					sessions.Statistics.Clear();
					await (FillDbAsync(CancellationToken.None));
					string logs = sl.GetWholeLog();
					Assert.That(logs, Does.Contain("batch").IgnoreCase);
					foreach (var loggingEvent in sl.Appender.GetEvents())
					{
						string message = loggingEvent.RenderedMessage;
						if(message.ToLowerInvariant().Contains("insert"))
						{
							Assert.That(message, Does.Contain("batch").IgnoreCase);
						}
					}
				}
			}

			Assert.That(sessions.Statistics.PrepareStatementCount, Is.EqualTo(1));
			await (CleanupAsync(CancellationToken.None));
		}

		[Test]
		public async Task SqlLogShouldGetBatchCommandNotificationAsync()
		{
			using (new LogSpy(typeof(AbstractBatcher)))
			{
				using (var sl = new SqlLogSpy())
				{
					sessions.Statistics.Clear();
					await (FillDbAsync(CancellationToken.None));
					string logs = sl.GetWholeLog();
					Assert.That(logs, Does.Contain("Batch commands:").IgnoreCase);
				}
			}

			Assert.That(sessions.Statistics.PrepareStatementCount, Is.EqualTo(1));
			await (CleanupAsync(CancellationToken.None));
		}

		[Test]
		[Description(@"Activating the AbstractBatcher's log the log stream:
-should contain well formatted SQL log info")]
		public async Task AbstractBatcherLogFormattedSqlAsync()
		{
			using (new LogSpy(typeof(AbstractBatcher)))
			{
				using (var sl = new SqlLogSpy())
				{
					sessions.Statistics.Clear();
					await (FillDbAsync(CancellationToken.None));
					foreach (var loggingEvent in sl.Appender.GetEvents())
					{
						string message = loggingEvent.RenderedMessage;
						if(message.StartsWith("Adding"))
						{
							// should be the line with the formatted SQL
							var strings = message.Split(System.Environment.NewLine.ToCharArray());
							foreach (var sqlLine in strings)
							{
								if(sqlLine.Contains("p0"))
								{
									Assert.That(sqlLine, Does.Contain("p1"));
									Assert.That(sqlLine, Does.Contain("p2"));
								}
							}
						}
					}
				}
			}

			Assert.That(sessions.Statistics.PrepareStatementCount, Is.EqualTo(1));
			await (CleanupAsync(CancellationToken.None));
		}
	}
}
